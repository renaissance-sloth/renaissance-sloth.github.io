---
title: "선택 정렬 및 퀵 정렬"
excerpt: "'알고리즘 개론' 과목의 정렬 강의입니다."
tags: syllabus computer-science algorithms
header:
  teaser: https://drive.google.com/thumbnail?id=1lkXN9-sYkNjHiBGc5cl_-pEltAkTfSZJ&sz=w1000
---

---

# 선택 정렬 및 퀵 정렬

## 선택 정렬

### 선택 정렬의 개념
배열: `9124536`
1.  첫 번째 요소를 최소값으로 설정합니다.
2.  최소값과 두 번째 요소를 비교하여, 두 번째 요소가 최소값보다 작으면 두 번째 요소를 새로운 최소값으로 할당합니다.
3.  3을 최소값으로 할당합니다.
4.  2가 최소값이 됩니다.
5.  1이 최소값이 됩니다.
6.  반복이 끝날 때 최소값을 첫 번째 요소와 교환합니다.
7.  다음 최소값을 찾습니다. (이 경우 2입니다). 최소값을 두 번째 요소와 교환합니다.
배열: `9634521`

### 알고리즘: `SELECTIONSORT(A, n)`
```
for i = 0 to n-2 // 외부 루프
  min = i
  for j = i + 1 to n-1 // 내부 루프
    if A[j] < A[min] then
      min = j
  end for
  if min != i then interchange A[i] and A[min]
end for
```
**시간 복잡도는 $O(n^2)$ 입니다.**

### Python 코드
```python
# Python으로 선택 정렬 구현
def selectionSort(array, size):
  for step in range(size):
    min_idx = step

    for i in range(step + 1, size):
      # 내림차순으로 정렬하려면 이 줄에서 >를 <로 변경합니다.
      # 각 루프에서 최소 요소를 선택합니다.
      if array[i] < array[min_idx]:
        min_idx = i

    # 최소값을 올바른 위치에 놓습니다.
    (array[step], array[min_idx]) = (array[min_idx], array[step])

data = [-2, 45, 0, 11, -9]
size = len(data)
selectionSort(data, size)
print('오름차순으로 정렬된 배열:')
print(data)
```

## 퀵 정렬

### 퀵 정렬의 개념
배열: `ans = 99124536`
아래 목록에서 정렬된 위치에 있는 요소가 무엇인지 말해줄 수 있나요?
배열: `ans = 1014131210764`
왜냐하면 **그 요소의 왼쪽에 있는 모든 요소는 그것보다 작고, 오른쪽에 있는 모든 요소는 그것보다 크기 때문입니다.**

퀵 정렬은 이 아이디어에 기반하여 작동합니다.
**요소의 왼쪽에 있는 모든 요소는 더 작아야 하고, 오른쪽에 있는 모든 요소는 더 커야 합니다.**

### 분할 정복 (퀵 정렬)
배열: `67312423 5` (n=8)

#### 알고리즘: `PARTITION(A, l, h)`
```
pivot = A[l]
i = l
j = h
while (i < j)
  do
    i++
    while (A[i] <= pivot)
      do
        j--
        while (A[j] > pivot)
          if (i < j)
            Swap(A[i], A[j])
Swap(A[l], A[j])
return j
```

#### 알고리즘: `QUICKSORT(A, l, h)`
```
if (l < h)
  j = PARTITION(A, l, h)
  QUICKSORT(A, l, j)
  QUICKSORT(A, j + 1, h)
```
이제 동일한 작업을 재귀적으로 수행합니다.

### 분할(Partition)
배열: `62317425`
`l` - 목록의 시작, `h` - 목록의 끝
첫 번째 요소를 피벗으로 선택합시다: `pivot = 5`

이제 5는 5보다 작은 모든 요소가 왼쪽에 오고, 5보다 큰 모든 요소가 오른쪽에 오도록 배치되어야 합니다.
`i`는 피벗보다 작은 요소를 찾습니다.
`j`는 피벗보다 큰 요소를 찾습니다.

#### 분할 과정
1.  `i`를 증가시키고, `element[i] > pivot`이 거짓이면 `j`를 감소시키고, `element[j] < pivot`이 거짓이면 `i`와 `j` 위치의 요소를 교환합니다.
2.  예시: 배열 `62317425`, 피벗 `5`
    -   `i` 증가: `2 > 5` (거짓), `4 > 5` (거짓), `7 > 5` (참) -> `i`는 7에서 멈춥니다.
    -   `j` 감소: `6 < 5` (거짓), `2 < 5` (참) -> `j`는 2에서 멈춥니다.
    -   `i`와 `j` 위치의 요소(7과 2)를 교환합니다. 배열: `62312475` (교환 후 `i`와 `j`는 계속 이동)
    -   `i` 증가: `3 > 5` (거짓), `7 > 5` (참) -> `i`는 7에서 멈춥니다.
    -   `j` 감소: `3 < 5` (참) -> `j`는 3에서 멈춥니다.
    -   `i > j` (거짓, `i=7, j=3`)
    -   `i`와 `j` 위치의 요소(7과 3)를 교환합니다. 배열: `62312475`
    -   루프는 `i > j`일 때 멈춥니다.
3.  이 시점에서 우리는 피벗의 위치(`j`)를 찾았습니다. `5`와 `3`을 교환합니다. `5`는 이제 정렬된 위치에 있습니다.

### 분할 정복 (퀵 정렬 개선)
이전의 두 개의 `while` 루프는 이 접근 방식에서 하나의 루프로 결합될 수 있습니다.
`i`는 처음에 `-1`로 설정됩니다.

#### 알고리즘: `PARTITION(A, l, h)` (개선된 버전)
```
pivot = A[h] // 피벗을 마지막 요소로 선택
i = l - 1
for j = l to h - 1
  if (A[j] <= pivot)
    i++
    Swap(A[i], A[j])
Swap(A[i + 1], A[h])
return i + 1
```
-   피벗 외의 각 요소를 처리합니다.
-   요소가 낮은 쪽에 속하는지 확인합니다.
-   낮은 쪽에 새 슬롯의 인덱스입니다.

#### 알고리즘: `QUICKSORT(A, l, h)` (개선된 버전)
```
if (l < h)
  j = PARTITION(A, l, h)
  QUICKSORT(A, l, j - 1) // 피벗 왼쪽 부분 재귀 호출
  QUICKSORT(A, j + 1, h) // 피벗 오른쪽 부분 재귀 호출
```
이제 동일한 작업을 재귀적으로 수행합니다.

### Python 코드 (퀵 정렬)
```python
def partition(arr, low, high):
  i = (low - 1)  # 작은 요소의 인덱스
  pivot = arr[high]  # 피벗

  for j in range(low, high):
    # 현재 요소가 피벗보다 작거나 같으면
    if arr[j] <= pivot:
      # 작은 요소의 인덱스를 증가시킵니다.
      i = i + 1
      arr[i], arr[j] = arr[j], arr[i]

  arr[i + 1], arr[high] = arr[high], arr[i + 1]
  return (i + 1)

def quickSort(arr, low, high):
  if len(arr) == 1:
    return arr
  if low < high:
    # pi는 분할 인덱스이며, arr[p]는 이제 제 위치에 있습니다.
    pi = partition(arr, low, high)

    # 분할 전후의 요소를 개별적으로 정렬합니다.
    quickSort(arr, low, pi - 1)
    quickSort(arr, pi + 1, high)

# 위 함수를 테스트하는 드라이버 코드
arr =
n = len(arr)
quickSort(arr, 0, n - 1)
print("정렬된 배열:")
for i in range(n):
  print("%d" % arr[i]),
```

### 빅 O 분석 (퀵 정렬)

*   **최고의 경우 (Best case) - $O(n \log n)$**
    *   분할 비용: $O(n)$
    *   $k = \log(n)$ 번 분할해야 합니다 (예: $n = 2^k \implies 8 = 2^k \implies k = \log_2 8$).
    *   퀵 정렬은 $O(n \log n)$ 시간으로 실행됩니다.
    *   이는 분할이 항상 중간에서 이루어질 때 발생합니다. 즉, 피벗 요소가 목록의 중앙값일 때입니다.

*   **최악의 경우 (Worst case) - $O(n^2)$**
    *   이는 요소가 이미 정렬되어 있을 때 발생합니다.
    *   `i`는 2번째 인덱스에서 멈추고 `j`는 1번째 인덱스에서 멈추며, 분할은 1번째 인덱스에서 발생합니다.
    *   따라서 분할은 항상 목록의 시작 부분에서 발생합니다.
    *   최악의 경우 시간 복잡도는 $n + (n-1) + (n-2) + \dots + 1 = \frac{n(n+1)}{2} = O(n^2)$ 입니다.

### 퀵 정렬의 최악의 경우를 해결하는 방법

*   항상 첫 번째 요소를 피벗으로 선택하지 마십시오.
*   가운데 요소를 피벗으로 선택하십시오.
*   무작위 요소를 피벗으로 선택하십시오.

퀵 정렬의 최악의 경우는 $O(n^2)$ 이고, 최고의 경우는 $O(n \log n)$ 입니다.

---

퀵 정렬은 마치 도서관에서 책을 정렬하는 것과 같습니다. 책을 무작위로 한 권 뽑아(피벗), 그 책보다 얇은 책들은 왼쪽에, 두꺼운 책들은 오른쪽에 놓습니다. 그리고 이 과정을 왼쪽 그룹과 오른쪽 그룹에 대해 계속 반복하여, 결국 모든 책이 정렬된 순서대로 놓이게 됩니다. 피벗을 잘 선택하면 정렬이 빠르게 끝나지만(최고의 경우), 항상 가장 얇은 책이나 가장 두꺼운 책을 피벗으로 뽑는다면(최악의 경우) 정렬하는 데 훨씬 더 많은 시간이 걸릴 수 있습니다.