---
title: "제9장: 그래프 탐색과 위상 정렬 (BFS, DFS, Topological Sort)" 
excerpt: "그래프 데이터를 순회하는 핵심 알고리즘인 너비 우선 탐색(BFS)과 깊이 우선 탐색(DFS)의 원리를 이해하고, 이를 응용한 위상 정렬과 코코 언어 문제 해결법을 다룹니다." 
tags: [algorithm, graph, bfs, dfs, topological sort, python] 
header: 
    teaser: https://drive.google.com/thumbnail?id=1lkXN9-sYkNjHiBGc5cl_-pEltAkTfSZJ&sz=w1000
---

이 문서는 그래프 자료구조의 핵심인 탐색 알고리즘(BFS, DFS)과 이를 활용한 위상 정렬(Topological Sort)에 대해 다룹니다. 그래프는 정점(Vertex)과 간선(Edge)으로 구성되며, 인접 리스트(Adjacency List)나 인접 행렬(Adjacency Matrix)로 표현할 수 있습니다 . 탐색은 그래프의 모든 정점을 방문하는 과정을 말하며, 어떤 순서로 방문하느냐에 따라 BFS와 DFS로 나뉩니다.

## 9.1 너비 우선 탐색 (BFS: Breadth First Search)

BFS는 시작 정점에서 가까운 정점부터 먼저 방문하고 멀리 있는 정점을 나중에 방문하는 순회 방법입니다. **큐(Queue)** 자료구조를 사용하여 구현합니다 .

### 9.1.1 BFS의 특징 및 동작 원리

  * **레벨 순서 순회:** 트리의 레벨 순서 순회와 유사하게, 자식 노드보다 형제 노드(Siblings)를 먼저 방문합니다.
  * **최단 경로 보장:** 비가중치 그래프(Unweighted Graph)에서 시작점으로부터 특정 정점까지의 최단 경로(최소 간선 수)를 찾는 데 적합합니다.
  * **동작 과정:**
    1.  시작 정점을 방문하고 큐에 삽입(Enqueue)합니다.
    2.  큐에서 정점을 하나 꺼내(Dequeue) 현재 노드로 설정합니다.
    3.  현재 노드의 인접 정점 중 방문하지 않은 모든 정점을 방문 표시 후 큐에 넣습니다.
    4.  큐가 빌 때까지 위 과정을 반복합니다 .

### 9.1.2 BFS 파이썬 구현 (인접 리스트 방식)

```python
from collections import defaultdict

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)

    def addEdge(self, u, v):
        self.graph[u].append(v)

    def BFS(self, s):
        # 모든 정점을 방문하지 않음으로 초기화
        visited = [False] * (max(self.graph) + 1)
        queue = []

        # 시작 노드를 큐에 넣고 방문 표시
        queue.append(s)
        visited[s] = True

        while queue:
            s = queue.pop(0)
            print(s, end=" ")

            # 인접한 정점들을 확인
            for i in self.graph[s]:
                if visited[i] == False:
                    queue.append(i)
                    visited[i] = True

# 실행 예제
g = Graph()
g.addEdge(0, 1); g.addEdge(0, 2); g.addEdge(1, 2)
g.addEdge(2, 0); g.addEdge(2, 3); g.addEdge(3, 3)

print("BFS 탐색 결과 (시작 정점 2):")
g.BFS(2)
```

## 9.2 깊이 우선 탐색 (DFS: Depth First Search)

DFS는 시작 정점에서 한 방향으로 갈 수 있는 데까지 깊게 들어갔다가, 더 이상 갈 곳이 없으면 가장 가까운 갈림길로 돌아와(Backtracking) 다른 방향을 탐색하는 방법입니다. **스택(Stack)** 자료구조나 \*\*재귀(Recursion)\*\*를 사용하여 구현합니다 .

### 9.2.1 DFS의 특징 및 동작 원리

  * **경로 탐색:** 미로 찾기나 퍼즐 문제와 같이 해가 존재할 때까지 한 경로를 끝까지 파고드는 문제에 적합합니다.
  * **구현:** 재귀 호출을 이용하면 코드가 간결해지며 스택을 명시적으로 관리할 필요가 없습니다 .
  * **순회 순서:** 전위 순회(Pre-order) 또는 후위 순회(Post-order) 방식으로 방문 순서를 기록할 수 있습니다 .

### 9.2.2 DFS 파이썬 구현 (재귀 방식)

```python
from collections import defaultdict

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)

    def addEdge(self, u, v):
        self.graph[u].append(v)

    def DFSUtil(self, v, visited):
        # 현재 노드 방문 표시 및 출력
        visited.add(v)
        print(v, end=' ')

        # 인접 노드 재귀 방문
        for neighbour in self.graph[v]:
            if neighbour not in visited:
                self.DFSUtil(neighbour, visited)

    def DFS(self, v):
        visited = set()
        self.DFSUtil(v, visited)

# 실행 예제
g = Graph()
g.addEdge(0, 1); g.addEdge(0, 2); g.addEdge(1, 2)
g.addEdge(2, 0); g.addEdge(2, 3); g.addEdge(3, 3)

print("DFS 탐색 결과 (시작 정점 2):")
g.DFS(2)
```

### 9.2.3 BFS와 DFS 비교

  * **시간 복잡도:** 두 알고리즘 모두 인접 리스트 사용 시 **$O(V+E)$**, 인접 행렬 사용 시 \*\*$O(V^2)$\*\*입니다.
  * **적합한 문제:** BFS는 최단 거리 탐색에, DFS는 의사결정 트리나 전체 경로 탐색에 유리합니다 .

## 9.3 위상 정렬 (Topological Sort)

위상 정렬은 유향 그래프의 정점들을 변의 방향을 거스르지 않도록 나열하는 것입니다. 어떤 일을 하는 순서를 정할 때(예: 선수 과목, 프로그램 의존성, 옷 입는 순서 등) 사용됩니다 .

### 9.3.1 조건 및 특징

  * **DAG 필수:** 위상 정렬은 반드시 \*\*사이클이 없는 유향 그래프(DAG, Directed Acyclic Graph)\*\*여야만 가능합니다. 사이클이 존재하면 위상 정렬을 수행할 수 없습니다.
  * **다양한 해:** 하나의 그래프에 대해 여러 개의 위상 정렬 결과가 존재할 수 있습니다.

### 9.3.2 칸의 알고리즘 (Kahn's Algorithm)

진입 차수(In-degree)를 이용한 BFS 기반의 위상 정렬 알고리즘입니다.

1.  모든 정점의 진입 차수를 계산합니다.
2.  진입 차수가 0인 정점들을 큐(Queue)에 넣습니다 .
3.  큐에서 정점을 꺼내 결과 리스트에 추가하고, 해당 정점에서 나가는 간선을 그래프에서 제거합니다(연결된 정점의 진입 차수를 1 감소시킵니다) .
4.  새롭게 진입 차수가 0이 된 정점을 큐에 넣습니다.
5.  큐가 빌 때까지 반복합니다. 만약 방문한 정점의 수가 전체 정점 수보다 적다면 사이클이 존재하는 것입니다 .

[그림: 진입 차수를 이용한 칸의 알고리즘 동작 과정]

### 9.3.3 위상 정렬 파이썬 구현

```python
from collections import defaultdict

class Graph:
    def __init__(self, vertices):
        self.graph = defaultdict(list)
        self.V = vertices

    def addEdge(self, u, v):
        self.graph[u].append(v)

    def topologicalSort(self):
        in_degree = [0] * (self.V)

        # 1. 모든 정점의 진입 차수 계산
        for i in self.graph:
            for j in self.graph[i]:
                in_degree[j] += 1

        # 2. 진입 차수가 0인 정점을 큐에 삽입
        queue = []
        for i in range(self.V):
            if in_degree[i] == 0:
                queue.append(i)

        cnt = 0
        top_order = []

        while queue:
            u = queue.pop(0)
            top_order.append(u)

            # 3. 인접 정점의 진입 차수 감소 및 0이 되면 큐에 삽입
            for i in self.graph[u]:
                in_degree[i] -= 1
                if in_degree[i] == 0:
                    queue.append(i)
            cnt += 1

        if cnt != self.V:
            print("사이클이 존재합니다.")
        else:
            print("위상 정렬 결과:", top_order)

# 실행 예제
g = Graph(6)
g.addEdge(5, 2); g.addEdge(5, 0); g.addEdge(4, 0); g.addEdge(4, 1)
g.addEdge(2, 3); g.addEdge(3, 1)

g.topologicalSort()
```

## 9.4 응용 문제: 코코 언어 (Alien Dictionary)

새로운 언어 'CoCo'의 단어들이 사전순으로 정렬된 리스트가 주어졌을 때, 이 언어의 알파벳 순서를 알아내는 문제입니다 .

### 9.4.1 해결 전략

1.  **그래프 생성:** 정렬된 단어 리스트에서 인접한 두 단어를 비교합니다.
2.  **간선 추출:** 두 단어에서 처음으로 달라지는 문자를 찾습니다. 앞 단어의 문자가 뒷 단어의 문자보다 순서상 앞서므로, `앞 문자 -> 뒷 문자` 방향의 간선을 그립니다 .
3.  **위상 정렬:** 생성된 그래프에 대해 위상 정렬을 수행하면 알파벳의 순서를 얻을 수 있습니다. 만약 사이클이 발견되면 유효하지 않은 순서입니다 .

<!-- end list -->

```python
# 코코 언어 문제 해결 예시 (개념적 코드)
def alienOrder(words):
    adj = {c: set() for w in words for c in w}
    in_degree = {c: 0 for c in adj}

    # 단어 간 비교를 통해 그래프 구축
    for i in range(len(words) - 1):
        w1, w2 = words[i], words[i + 1]
        min_len = min(len(w1), len(w2))
        if len(w1) > len(w2) and w1[:min_len] == w2[:min_len]:
            return "" # 잘못된 입력
        for j in range(min_len):
            if w1[j] != w2[j]:
                if w2[j] not in adj[w1[j]]:
                    adj[w1[j]].add(w2[j])
                    in_degree[w2[j]] += 1
                break

    # 위상 정렬 (Kahn's Algorithm)
    queue = [c for c in in_degree if in_degree[c] == 0]
    result = []
    while queue:
        c = queue.pop(0)
        result.append(c)
        for neighbor in adj[c]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)

    if len(result) < len(in_degree):
        return "" # 사이클 존재
    return "".join(result)
