---
title: "제7장: 동적 계획법 (Dynamic Programming)"
excerpt: "복잡한 최적화 문제를 작은 하위 문제로 나누어 해결하는 동적 계획법(DP)의 핵심 원리와 피보나치, 배낭 문제, MCM, LCS 등 주요 알고리즘의 파이썬 구현을 다룹니다."
tags: [algorithm, dynamic programming, python, optimization, computer science]
header:
  teaser: https://drive.google.com/thumbnail?id=1lkXN9-sYkNjHiBGc5cl_-pEltAkTfSZJ&sz=w1000
---

이 문서는 동적 계획법(Dynamic Programming, DP)의 기본 개념부터 심화 알고리즘까지 포괄적으로 다룹니다. 동적 계획법은 최적화 문제를 해결하기 위해 문제를 중복되는 부분 문제로 나누고, 그 해를 저장하여 재사용함으로써 계산 효율을 극대화하는 기법입니다. 본문에서는 피보나치 수열, 0/1 배낭 문제, 행렬 연쇄 곱셈(MCM), 최장 공통 부분 수열(LCS)을 예제로 하여 메모이제이션(Memoization)과 타뷸레이션(Tabulation)의 차이와 구현 방법을 상세히 설명합니다.

## 7.1 동적 계획법 개요

동적 계획법은 주로 **최적화 문제(Optimization Problem)**, 즉 특정 조건을 만족하는 최대값이나 최소값을 구하는 문제에 사용됩니다. DP가 성립하기 위해서는 다음 두 가지 속성이 필요합니다.

1.  **중복되는 부분 문제 (Overlapping Subproblems):** 큰 문제를 해결하기 위해 작은 문제들이 반복적으로 호출되는 구조여야 합니다.
2.  **최적 부분 구조 (Optimal Substructure):** 부분 문제의 최적해를 결합하여 전체 문제의 최적해를 구성할 수 있어야 합니다.

### 7.1.1 다른 알고리즘과의 비교
* **분할 정복 (Divide and Conquer):** 문제를 서로 겹치지 않는(Disjoint) 하위 문제로 나누어 풉니다. 반면, DP는 하위 문제가 서로 겹칠 때 그 결과를 저장(Memoization)하여 중복 계산을 방지합니다.
* **탐욕 알고리즘 (Greedy):** 각 단계에서 당장 최선이라 생각되는 선택(Local Optimum)을 하지만, DP는 모든 가능한 하위 문제의 해를 고려하여 전역 최적해(Global Optimum)를 보장합니다.

[그림: 분할 정복과 동적 계획법의 부분 문제 중복 여부 비교]

## 7.2 피보나치 수열 (Fibonacci Sequence)

피보나치 수열은 DP의 가장 대표적인 예제입니다. 점화식은 다음과 같습니다.

$$F_0 = 0, \quad F_1 = 1$$
$$F_n = F_{n-1} + F_{n-2} \quad (n \ge 2)$$

### 7.2.1 재귀와 DP의 성능 차이
단순 재귀로 구현하면 $F(n)$을 구하기 위해 $F(n-1)$과 $F(n-2)$를 호출하며, 중복 호출로 인해 시간 복잡도가 $O(2^n)$이 됩니다. DP를 사용하면 이를 $O(n)$으로 줄일 수 있습니다.

### 7.2.2 구현: 메모이제이션 vs 타뷸레이션
* **메모이제이션 (Top-Down):** 재귀 호출 시 계산된 값을 `lookup` 테이블에 저장하고, 이미 계산된 값이면 이를 반환합니다.
* **타뷸레이션 (Bottom-Up):** 작은 값부터 반복문(Iterative)을 통해 테이블을 채워 나갑니다.

```python
# 피보나치 수열 구현 (Python)

# 1. 단순 재귀 (비효율적, O(2^n))
def fib_recursive(n):
    if n <= 1:
        return n
    return fib_recursive(n-1) + fib_recursive(n-2)

# 2. 메모이제이션 (Top-Down, O(n))
def fib_memo(n, lookup):
    if n <= 1:
        return n
    # 이미 계산된 값이면 반환
    if lookup[n] is not None:
        return lookup[n]
    # 계산 후 테이블에 저장
    lookup[n] = fib_memo(n-1, lookup) + fib_memo(n-2, lookup)
    return lookup[n]

# 3. 타뷸레이션 (Bottom-Up, O(n))
def fib_tabulation(n):
    if n <= 1:
        return n
    dp = [0] * (n + 1)
    dp[1] = 1
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]

# 실행 코드
n = 10
lookup = [None] * (n + 1)
print(f"Fibonacci({n}) Memoization: {fib_memo(n, lookup)}")
print(f"Fibonacci({n}) Tabulation: {fib_tabulation(n)}")
```

## 7.3 0/1 배낭 문제 (0/1 Knapsack Problem)

배낭 문제는 제한된 무게 $W$ 내에서 물건들의 가치 합이 최대가 되도록 선택하는 문제입니다. 0/1 배낭 문제는 물건을 쪼갤 수 없으며, 넣거나(1) 넣지 않거나(0)의 선택만 가능합니다.

### 7.3.1 문제 정의 및 점화식

  * $n$: 물건의 개수
  * $W$: 배낭의 용량
  * $val[]$: 물건의 가치, $wt[]$: 물건의 무게
  * $K[i][w]$: $i$번째 물건까지 고려하고 배낭 용량이 $w$일 때의 최대 가치

점화식은 다음과 같습니다:
$$K[i][w] = \max(val[i-1] + K[i-1][w-wt[i-1]], \quad K[i-1][w])$$
(단, $wt[i-1] \le w$인 경우. 물건이 배낭보다 무거우면 이전 상태 $K[i-1][w]$를 유지합니다.)

[그림: 0/1 배낭 문제의 DP 테이블 채우기 과정]

```python
# 0/1 배낭 문제 (Tabulation)
def knapsack_01(W, wt, val, n):
    # DP 테이블 초기화 (n+1 x W+1)
    K = [[0 for x in range(W + 1)] for x in range(n + 1)]

    for i in range(n + 1):
        for w in range(W + 1):
            if i == 0 or w == 0:
                K[i][w] = 0
            elif wt[i-1] <= w:
                # i번째 물건을 포함하는 경우 vs 포함하지 않는 경우 중 최대값
                K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]], K[i-1][w])
            else:
                # 현재 물건이 배낭 용량보다 크면 포함 불가
                K[i][w] = K[i-1][w]

    return K[n][W]

# 실행 예제
val = [1, 2, 5, 6]
wt = [2, 3, 4, 5]
W = 8
n = len(val)
print(f"0/1 배낭 최대 가치: {knapsack_01(W, wt, val, n)}")
```

## 7.4 무제한 배낭 문제 (Unbounded Knapsack)

0/1 배낭 문제와 달리, 물건을 개수 제한 없이 중복해서 선택할 수 있는 문제입니다. 예를 들어, 무게 4인 물건을 배낭 용량이 허용하는 한 여러 번 넣을 수 있습니다.

### 7.4.1 점화식의 차이

물건을 선택했을 때 이전 단계($i-1$)가 아닌 현재 단계($i$)의 상태를 다시 참조합니다.
$$K[i][w] = \max(val[i-1] + K[i][w-wt[i-1]], \quad K[i-1][w])$$

```python
# 무제한 배낭 문제 (Unbounded Knapsack)
def unbounded_knapsack(W, n, val, wt):
    # dp[w]는 배낭 용량이 w일 때의 최대 가치 (1차원 배열로 최적화 가능)
    dp = [0] * (W + 1)
    
    for i in range(W + 1):
        for j in range(n):
            if wt[j] <= i:
                # 현재 물건(j)을 추가했을 때의 가치와 기존 가치 비교
                dp[i] = max(dp[i], dp[i - wt[j]] + val[j])
                
    return dp[W]

# 실행 예제
print(f"무제한 배낭 최대 가치: {unbounded_knapsack(8, 4, [1, 2, 5, 6], [2, 3, 4, 5])}")
```

## 7.5 행렬 연쇄 곱셈 (Matrix Chain Multiplication, MCM)

일련의 행렬 $A_1, A_2, \dots, A_n$을 곱할 때, 연산 횟수(스칼라 곱셈)가 최소가 되도록 괄호를 묶는 최적의 순서를 찾는 문제입니다. 행렬 곱셈은 결합 법칙이 성립하지만, 연산 비용은 순서에 따라 달라집니다.

### 7.5.1 점화식

행렬 $A_i$의 차원이 $p[i-1] \times p[i]$일 때, $i$부터 $j$까지의 최소 곱셈 비용 $m[i, j]$는 다음과 같습니다.

$$m[i, j] = \begin{cases} 0 & \text{if } i = j \\ \min_{i \le k < j} \{ m[i, k] + m[k+1, j] + p[i-1] \times p[k] \times p[j] \} & \text{if } i < j \end{cases}$$

여기서 $k$는 행렬을 나누는 분기점입니다.

[그림: 행렬 곱셈 순서 결정을 위한 재귀 트리와 DP 테이블 구조]

```python
# 행렬 연쇄 곱셈 (MCM) - Tabulation
import sys

def matrix_chain_order(p, n):
    # m[i][j]는 Ai...Aj 행렬 곱의 최소 연산 횟수
    # 1번 인덱스부터 사용하기 위해 n x n 크기 할당
    m = [[0 for x in range(n)] for x in range(n)]

    # L은 행렬 체인의 길이 (2부터 시작)
    for L in range(2, n):
        for i in range(1, n - L + 1):
            j = i + L - 1
            m[i][j] = sys.maxsize
            
            # k는 분할 위치 (i부터 j-1까지)
            for k in range(i, j):
                # 비용 = 왼쪽 부분 비용 + 오른쪽 부분 비용 + 현재 곱셈 비용
                q = m[i][k] + m[k+1][j] + p[i-1] * p[k] * p[j]
                if q < m[i][j]:
                    m[i][j] = q
                    
    return m[1][n-1]

# 실행 예제
# 행렬 크기: A1(5x4), A2(4x6), A3(6x2), A4(2x7)
arr = [5, 4, 6, 2, 7]
size = len(arr)
print(f"최소 곱셈 횟수: {matrix_chain_order(arr, size)}")
```

## 7.6 최장 공통 부분 수열 (LCS, Longest Common Subsequence)

두 문자열 $X$와 $Y$가 주어졌을 때, 두 문자열 모두의 부분 수열이 되는 가장 긴 문자열을 찾는 문제입니다. 부분 수열은 문자열 내에서 문자의 순서는 유지되지만 연속적일 필요는 없습니다.

### 7.6.1 점화식

두 문자열의 길이를 각각 $m, n$이라 할 때, $LCS(i, j)$는 $X[0\dots i-1]$와 $Y[0\dots j-1]$의 LCS 길이입니다.

1.  $X[i-1] == Y[j-1]$이면:
    $$LCS(i, j) = 1 + LCS(i-1, j-1)$$
2.  $X[i-1] \neq Y[j-1]$이면:
    $$LCS(i, j) = \max(LCS(i-1, j), LCS(i, j-1))$$

[그림: LCS 계산을 위한 2차원 DP 테이블 예시]

```python
# 최장 공통 부분 수열 (LCS) - Tabulation
def lcs_tabulation(X, Y):
    m = len(X)
    n = len(Y)
    
    # DP 테이블 초기화 (m+1 x n+1)
    dp = [[0] * (n + 1) for i in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if X[i-1] == Y[j-1]:
                # 문자가 같으면 대각선 값 + 1
                dp[i][j] = 1 + dp[i-1][j-1]
            else:
                # 다르면 왼쪽이나 위쪽 값 중 최대값 선택
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
                
    return dp[m][n]

# 실행 예제
X = "AGGTAB"
Y = "GXTXAYB"
print(f"LCS 길이: {lcs_tabulation(X, Y)}")
```

## 7.7 결론: 메모이제이션과 타뷸레이션

동적 계획법은 재귀적인 구조를 가지지만, 중복 계산을 피하는 것이 핵심입니다.

  * **메모이제이션(Top-Down):** 필요한 하위 문제만 계산하므로 경우에 따라 빠를 수 있지만, 재귀 호출의 깊이가 깊어지면 스택 오버플로우 위험이 있습니다.
  * **타뷸레이션(Bottom-Up):** 모든 하위 문제를 순차적으로 계산하며, 재귀 호출 오버헤드가 없어 공간 효율성과 성능 면에서 더 안정적입니다.

동적 계획법은 알고리즘 문제 해결뿐만 아니라 시스템 최적화, 생물 정보학 등 다양한 분야에서 필수적으로 사용되는 기법입니다.
