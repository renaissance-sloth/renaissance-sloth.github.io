---
title: "제10장: 힙 (Heap)과 우선순위 큐" 
excerpt: "완전 이진 트리를 기반으로 한 힙 자료구조의 원리, 힙 정렬, 그리고 우선순위 큐의 구현과 응용(K번째 원소 찾기 등)을 다룹니다." 
tags: [algorithm, heap, priority queue, python, sorting] 
header: 
    teaser: https://drive.google.com/thumbnail?id=1lkXN9-sYkNjHiBGc5cl_-pEltAkTfSZJ&sz=w1000
---

이 챕터에서는 **힙(Heap)** 자료구조의 개념과 이를 이용한 **힙 정렬(Heap Sort)**, **우선순위 큐(Priority Queue)**에 대해 심도 있게 학습합니다. 힙은 완전 이진 트리(Complete Binary Tree)를 기반으로 하여 최댓값이나 최솟값을 빠르게 찾아내도록 설계된 자료구조입니다. 본문에서는 힙의 배열 표현 방식, 삽입 및 삭제 연산의 원리, 그리고 파이썬의 `heapq` 모듈을 활용한 K번째 원소 찾기 등의 응용 문제를 다룹니다 .

## 10.1 힙(Heap)의 개요

힙은 **완전 이진 트리(Complete Binary Tree)**의 일종으로, 부모 노드와 자식 노드 간에 특정한 대소 관계가 성립하는 자료구조입니다. 배열을 사용하여 효율적으로 구현할 수 있습니다 .

### 10.1.1 힙의 종류

  * **최대 힙 (Max Heap):** 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리입니다 ($Parent \ge Child$).
  * **최소 힙 (Min Heap):** 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리입니다 ($Parent \le Child$).

### 10.1.2 배열을 이용한 표현

힙은 배열로 구현할 때 인덱스를 통해 부모와 자식 간의 관계를 쉽게 정의할 수 있습니다. 노드가 인덱스 $i$에 위치할 때 (1-based index 기준):

  * **왼쪽 자식:** $2 \times i$
  * **오른쪽 자식:** $2 \times i + 1$
  * **부모 노드:** $\lfloor i / 2 \rfloor$ .

0-based index를 사용할 경우, 왼쪽 자식은 $2i+1$, 오른쪽 자식은 $2i+2$, 부모는 $(i-1)//2$가 됩니다.

## 10.2 힙의 주요 연산

힙의 핵심은 데이터가 삽입되거나 삭제될 때 힙의 성질(Heap Property)을 유지하는 것입니다.

### 10.2.1 삽입 (Insertion)

새로운 원소는 배열의 가장 마지막 위치(트리의 가장 아래 오른쪽)에 추가됩니다. 그 후, 부모 노드와 비교하며 힙의 조건을 만족할 때까지 위로 올라가는 과정(**Up-Heap** 또는 **Bubble-Up**)을 거칩니다.

  * **시간 복잡도:** 트리의 높이에 비례하므로 $O(\log n)$입니다.

### 10.2.2 삭제 (Deletion)

힙에서의 삭제는 항상 **루트 노드(Root Node)**, 즉 최댓값(Max Heap)이나 최솟값(Min Heap)을 제거하는 것을 의미합니다.

1.  루트 노드를 제거합니다.
2.  배열의 가장 마지막 원소를 루트 자리로 옮깁니다.
3.  자식 노드들과 비교하며 힙의 조건을 만족할 때까지 아래로 내려가는 과정(**Down-Heap** 또는 **Heapify**)을 수행합니다 .

<!-- end list -->

  * **시간 복잡도:** $O(\log n)$.

## 10.3 힙 정렬 (Heap Sort)

힙 정렬은 힙 자료구조를 이용하여 데이터를 정렬하는 알고리즘입니다. 과정은 크게 두 단계로 나뉩니다 .

1.  **힙 생성 (Build Heap):** 주어진 데이터들을 힙 구조(Max Heap 등)로 만듭니다. `Heapify` 과정을 통해 수행하며, 시간 복잡도는 $O(n)$입니다.
2.  **정렬 (Sort):** 루트(최댓값)를 꺼내 배열의 뒤쪽으로 보내고, 힙 크기를 줄인 후 다시 힙 속성을 유지(Heapify)합니다. 이 과정을 반복하면 정렬된 배열을 얻을 수 있습니다.

<!-- end list -->

  * **총 시간 복잡도:** $O(n \log n)$.

<!-- end list -->

```python
# 힙 정렬 구현 (Max Heap 기준)
def heapify(arr, n, i):
    largest = i  # 루트를 가장 큰 값으로 가정
    l = 2 * i + 1     # 왼쪽 자식
    r = 2 * i + 2     # 오른쪽 자식
  
    # 왼쪽 자식이 루트보다 크면 largest 갱신
    if l < n and arr[i] < arr[l]:
        largest = l
  
    # 오른쪽 자식이 현재 largest보다 크면 갱신
    if r < n and arr[largest] < arr[r]:
        largest = r
  
    # largest가 루트가 아니라면 교체(swap) 후 재귀 호출
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
  
def heapSort(arr):
    n = len(arr)
  
    # 1. Max Heap 생성 (Build Heap)
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
  
    # 2. 하나씩 요소를 꺼내어 정렬
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]   # 루트(최대값)를 끝으로 보냄
        heapify(arr, i, 0) # 줄어든 힙에 대해 heapify 수행
  
# 실행 예제
arr = [12, 11, 13, 5, 6, 7]
heapSort(arr)
print("Sorted array is:", arr)
```

## 10.4 우선순위 큐 (Priority Queue)

우선순위 큐는 들어온 순서와 상관없이 **우선순위가 높은 데이터가 먼저 나가는** 자료구조입니다. 힙은 우선순위 큐를 구현하는 가장 효율적인 방법입니다.

  * **Max Heap:** 숫자가 클수록 우선순위가 높은 경우 사용.
  * **Min Heap:** 숫자가 작을수록 우선순위가 높은 경우 사용.

## 10.5 응용: K번째 요소 찾기

힙은 전체 데이터를 정렬하지 않고도 K번째로 큰(또는 작은) 값을 효율적으로 찾는 데 유용합니다.

  * **K번째 작은 수:** Max Heap을 사용하여 크기를 K로 유지하거나, Min Heap에 모든 데이터를 넣고 K번 `pop`을 수행합니다.
  * **K번째 큰 수:** Min Heap을 사용하여 크기를 K로 유지하면, 힙의 루트에 K번째로 큰 수가 남게 됩니다. 이 방식의 시간 복잡도는 $O(n \log k)$로, 전체 정렬($O(n \log n)$)보다 효율적입니다.

<!-- end list -->

```python
import heapq

class Solution:
    # Min Heap을 이용한 K번째 큰 수 찾기 (크기 K 유지)
    def findKthLargest(self, nums, k):
        heap = []
        for num in nums:
            heapq.heappush(heap, num)
            if len(heap) > k:
                heapq.heappop(heap) # 가장 작은 값을 제거하여 큰 값들만 남김
        return heap[0] # K개의 큰 수 중 가장 작은 값이 K번째 큰 수

    # Max Heap을 이용한 K번째 작은 수 찾기 (음수로 변환하여 사용)
    def findKthSmallest(self, nums, k):
        max_heap = []
        for num in nums:
            heapq.heappush(max_heap, -num) # Python heapq는 min heap이므로 음수로 변환
            if len(max_heap) > k:
                heapq.heappop(max_heap)
        return -max_heap[0]

# 실행 예제
sol = Solution()
nums = [7, 10, 4, 3, 20, 15]
k = 3
print(f"{k}번째 큰 수: {sol.findKthLargest(nums, k)}")
print(f"{k}번째 작은 수: {sol.findKthSmallest(nums, k)}")
```

## 10.6 요약

  * **힙(Heap)**은 완전 이진 트리 형태의 자료구조로, 최댓값이나 최솟값을 $O(1)$에 찾고, 삽입/삭제를 $O(\log n)$에 수행합니다.
  * **힙 정렬(Heap Sort)**은 추가적인 메모리 공간을 거의 사용하지 않는 제자리 정렬(In-place Sort)이며, 항상 $O(n \log n)$의 성능을 보장합니다.
  * **우선순위 큐(Priority Queue)** 구현에 최적화되어 있으며, 다익스트라 알고리즘, 프림 알고리즘, 허프만 코딩 등 다양한 탐욕 알고리즘(Greedy Algorithm)의 핵심 부품으로 사용됩니다.
