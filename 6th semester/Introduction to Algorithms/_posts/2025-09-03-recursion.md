---
title: "재귀"
excerpt: "'알고리즘 개론' 과목의 2번째 강의입니다."
tags: syllabus computer-science algorithms
header:
  teaser: https://drive.google.com/thumbnail?id=1lkXN9-sYkNjHiBGc5cl_-pEltAkTfSZJ&sz=w1000
---

**재귀 (Recursion) 개요**

재귀는 컴퓨터 프로그램 내에서 **반복**을 수행하는 중요한 기술로, `while` 루프나 `for` 루프와 같은 **반복(iteration)** 방식의 우아하고 강력한 대안입니다. 자료 구조와 알고리즘 연구에서 중요한 개념으로 다루어집니다.

**재귀를 사용하는 이유**
재귀는 많은 **자료 구조**와 **고급 알고리즘**에서 활용됩니다.
*   **배열/문자열 문제**.
*   **트리**는 전적으로 재귀에 의존합니다.
*   **그래프**의 DFS/BFS (깊이 우선 탐색/너비 우선 탐색).
*   **스택/힙** (부분적으로 재귀 기반).
*   **동적 프로그래밍 (DP)**.
*   **백트래킹 (Backtracking)**.
*   **분할 정복 (Divide and Conquer)**.
코딩 인터뷰에서 재귀 준비 없이는 어려움을 겪을 수 있다고 강조됩니다.

**재귀적 함수의 동작 방식 (메모리)**
재귀 함수가 메모리에서 어떻게 작동하는지에 대한 내용도 포함되어 있습니다.

**재귀에 대한 접근 방식**
재귀 문제에 접근하는 두 가지 주요 방식이 제시됩니다:

1.  **첫 번째 접근 방식: 기본 조건(Base condition) -> 가설(Hypothesis) -> 유도(Induction)**
    *   **기본 조건:** 가장 작은 유효 입력에 기반합니다. 예를 들어, `print(n)` 함수에서 `n == 1`일 때 `n`을 출력하고 반환하는 것입니다.
    *   **가설:** `print(n)`이 1부터 `n`까지 출력한다고 가정하면, `print(n-1)`은 1부터 `n-1`까지 출력할 것이라는 가설을 세웁니다.
    *   **유도:** 가설을 바탕으로 `print(n-1)`을 호출한 후 `n`을 출력하여 `print(n)`이 올바르게 작동하도록 만듭니다.
    *   팩토리얼 문제에도 이 접근 방식을 적용할 수 있습니다.

2.  **두 번째 접근 방식: 선택(Choices) -> 결정(Decision)**
    *   이 접근 방식은 **문제의 크기를 줄이는 결정**을 내리는 데 중점을 둡니다.
    *   **재귀 트리(Recursion Tree)**를 그리는 것이 가장 중요하며, 트리의 각 가지는 가능한 **선택**을 나타냅니다. 재귀 트리를 잘 설계하면 코드 작성은 쉬워집니다.
    *   입력이 주어지면, 선택을 하고 결정을 내리면 입력의 크기가 작아집니다. 이러한 과정을 가장 작은 유효 입력이 될 때까지 반복합니다.
    *   예를 들어, "abc"의 부분집합을 찾는 문제에서 각 문자를 포함할지 말지를 결정하는 것이 해당됩니다. 이러한 결정은 입력 문자열의 크기를 줄입니다.

**재귀의 예시**
*   1부터 n까지/n부터 1까지 출력하기.
*   배열 정렬/스택 요소 정렬.
*   스택의 중간 요소 삭제.
*   문자열에서 중복 제거.
*   문자열에서 특정 문자 발생 횟수 세기.
*   부분집합 (Subset).
*   공백이 있는 순열 (Permutation with C spaces).
*   균형 잡힌 괄호 생성 (Generate a balanced parenthesis).

**재귀를 기반으로 하는 정렬 알고리즘**
*   **병합 정렬 (Merge Sort):** 분할 정복(Divide and Conquer) 방식의 예시로, 문제를 작은 부분 문제로 나누고 재귀적으로 해결한 후 결합합니다.
*   **퀵 정렬 (Quick Sort):** 역시 분할 정복 방식의 예시로, 파티션을 나누고 재귀적으로 정렬합니다.

재귀는 루프 없이도 복잡한 문제를 해결할 수 있는 강력한 도구이며, 특히 데이터 구조를 다루거나 최적화 문제에서 유용합니다. 재귀의 핵심은 각 함수 호출에서 입력의 크기를 줄이고, 최종적으로 기본 조건에 도달하여 문제를 해결하는 것입니다.