---
title: "삽입 정렬과 병합 정렬"
excerpt: "'알고리즘 개론' 과목의 정렬 강의입니다."
tags: syllabus computer-science algorithms
header:
  teaser: https://drive.google.com/thumbnail?id=1lkXN9-sYkNjHiBGc5cl_-pEltAkTfSZJ&sz=w1000
---

## 삽입 정렬과 병합 정렬

알고리즘의 세계에서 '정렬'은 가장 기본적이면서도 중요한 개념 중 하나입니다. 데이터를 특정 순서에 따라 재배열하는 과정은 검색, 데이터베이스 관리, 그래픽 처리 등 수많은 응용 분야에서 핵심적인 역할을 합니다. 이번 포스팅에서는 두 가지 대표적인 정렬 알고리즘인 **삽입 정렬(Insertion Sort)**과 **병합 정렬(Merge Sort)**을 자세히 살펴보고, 이들의 작동 방식, 의사 코드, 파이썬 구현, 그리고 성능 분석(빅 O 표기법)에 대해 알아보겠습니다.

### 알고리즘 성능 측정: 빅 O 표기법

알고리즘의 성능을 평가하는 가장 중요한 기준 중 하나는 **연산 횟수**, 즉 **시간 복잡도**입니다. 이를 수학적으로 표현하는 방법이 바로 **빅 O 표기법(Big O Notation)**입니다. 빅 O는 입력 크기가 증가함에 따라 알고리즘의 실행 시간이나 공간 요구 사항이 어떻게 증가하는지 분류하는 데 사용되는 표기법입니다.

*   **O(1)**: 상수 시간 복잡도. 입력 크기에 관계없이 연산 횟수가 일정합니다.
*   **O(n)**: 선형 시간 복잡도. 입력 크기(n)에 비례하여 연산 횟수가 증가합니다. (예: 순차 검색)
*   **O(log n)**: 로그 시간 복잡도. 입력 크기가 커질수록 연산 횟수의 증가율이 둔화됩니다. (예: 이진 검색)
*   **O(n log n)**: n-로그-n 시간 복잡도. 효율적인 정렬 알고리즘에서 흔히 볼 수 있는 성능입니다.
*   **O(n²)**: 제곱 시간 복잡도. 입력 크기의 제곱에 비례하여 연산 횟수가 급격히 증가합니다. (예: 삽입 정렬, 거품 정렬)
*   **O(2^n)**: 지수 시간 복잡도. 입력 크기가 조금만 커져도 연산 횟수가 폭발적으로 증가합니다.
*   **O(n!)**: 팩토리얼 시간 복잡도. 매우 비효율적인 알고리즘에서 나타납니다.

이러한 빅 O 표기법은 알고리즘의 확장성을 이해하고, 대규모 데이터셋에 어떤 알고리즘이 더 적합한지 판단하는 데 필수적인 도구입니다.

### 1. 삽입 정렬(Insertion Sort)

삽입 정렬은 **사람이 카드 패를 정리하는 방식**과 유사합니다. 아직 정렬되지 않은 부분에서 하나의 요소를 가져와 이미 정렬된 부분의 올바른 위치에 '삽입'하는 방식으로 작동합니다.

#### 작동 방식

주어진 배열을 **정렬된 부분**과 **정렬되지 않은 부분**으로 나눕니다.
1.  정렬되지 않은 부분에서 첫 번째 요소를 선택합니다. 이를 `key`라고 합니다.
2.  `key`를 정렬된 부분의 요소들과 비교하여 `key`보다 큰 요소들을 한 칸씩 뒤로 밀어냅니다.
3.  `key`가 들어갈 빈자리를 찾으면 그 자리에 `key`를 삽입합니다.
4.  정렬되지 않은 부분이 없어질 때까지 이 과정을 반복합니다.

**예시:** `` 정렬

*   `` 정렬됨, `` 정렬 안 됨
    *   `key = 2` (두 번째 요소). `6`보다 작으므로 `6`을 뒤로 밀고 `2`를 삽입.
*   `` 정렬됨, `` 정렬 안 됨
    *   `key = 3`. `6`보다 작고 `2`보다 크므로 `6`을 뒤로 밀고 `3`을 삽입.
*   `` 정렬됨, `` 정렬 안 됨
    *   `key = 1`. `6, 3, 2`보다 모두 작으므로 모두 뒤로 밀고 `1`을 삽입.
*   `` 정렬됨, `` 정렬 안 됨
    *   ... 이 과정을 반복하여 최종적으로 정렬된 배열을 얻습니다.

#### 의사 코드 (Pseudocode)

```
알고리즘: INSERTION-SORT(A)
  변수 선언 – i, key, j
  for i = 1 to n – 1 // 외부 루프: 정렬되지 않은 부분에서 요소를 선택
      key = A[i] // 다음 요소 선택
      j = i – 1 // key를 비교할 정렬된 부분의 마지막 인덱스
      while (j >= 0 && A[j] > key) // 내부 루프: key의 올바른 위치를 찾고 큰 요소들을 뒤로 이동
          A[j+1] = A[j]
          j = j – 1
      A[j+1] = key // key를 올바른 위치에 삽입
```

#### 파이썬 코드 (Python Code)

```python
def insertionSort(arr):
    # arr의 1부터 len(arr)까지 순회
    for i in range(1, len(arr)):
        key = arr[i]
        # arr[0..i-1]에 있는 요소 중
        # key보다 큰 요소들을 현재 위치보다 한 칸
        # 앞으로 이동
        j = i-1
        while j >=0 and key < arr[j] :
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key

# 위 코드를 테스트하기 위한 드라이버 코드
# arr =
# insertionSort(arr)
# print ("정렬된 배열:")
# for i in range(len(arr)):
#     print ("%d" %arr[i])
```

#### 빅 O 분석 (Big O Analysis)

삽입 정렬은 중첩된 `for` 루프(`while` 루프 포함)를 가지고 있으며, 최악의 경우 (예: 역순으로 정렬된 배열) 모든 요소를 여러 번 비교하고 이동해야 합니다. 따라서 삽입 정렬의 시간 복잡도는 **O(n²)**입니다. 이는 작은 데이터셋에서는 괜찮지만, `n`이 커질수록 성능이 급격히 저하됨을 의미합니다.

### 2. 병합 정렬 (Merge Sort)

병합 정렬은 **분할 정복(Divide-and-Conquer)**이라는 강력한 알고리즘 설계 패러다임을 사용하는 대표적인 정렬 알고리즘입니다. 이 패러다임은 문제를 여러 개의 작은 하위 문제로 나누고(Divide), 각 하위 문제를 독립적으로 해결한 다음(Conquer), 이 하위 문제들의 해결책을 결합하여 원래 문제의 해결책을 도출합니다(Combine).

#### 분할 정복(Divide-and-Conquer) 원칙

1.  **분할(Divide)**: 문제를 여러 개의 하위 문제로 나눕니다. 이 하위 문제들은 원래 문제와 유사하지만 크기가 더 작습니다.
2.  **정복(Conquer)**: 하위 문제들을 재귀적으로 해결합니다. 하위 문제의 크기가 충분히 작아지면 (보통 단일 요소 배열이 되면) 직접적인 방식으로 해결합니다.
3.  **결합(Combine)**: 하위 문제들의 해결책을 결합하여 원래 문제에 대한 해결책을 얻습니다. 병합 정렬에서는 이 단계가 '병합(Merge)' 과정에 해당합니다.

#### 작동 방식

1.  **분할(Divide)**: 배열을 절반으로 계속 나눕니다. (단일 요소가 될 때까지 분할)

2.  **정복 및 결합(Conquer and Merge)**: 단일 요소 배열은 이미 정렬되어 있다고 간주하고, 분할의 역순으로 정렬된 하위 배열을 하나로 병합합니다.

#### 병합(Merge)의 핵심 아이디어

두 개의 정렬된 카드 더미(부분 배열)가 있을 때, 두 더미의 가장 위에 있는 카드 중 **더 작은 것을 선택**하여 새로운 출력 더미에 놓습니다. 한 더미가 비워질 때까지 이 과정을 반복하고, 남은 더미의 카드들을 모두 출력 더미 위에 놓습니다. 이 과정에서 임시 배열을 사용하여 데이터 이동을 효율적으로 처리하며, 무한대(`∞`)와 같은 센티넬(sentinel) 값을 사용하여 비교 로직을 단순화할 수 있습니다.

#### 의사 코드 (Pseudocode)

**MERGE-SORT(A, p, r)**
```
if p < r // 기저 사례 확인: p가 r보다 작아야 분할 가능 (배열이 2개 이상)
then q ← ⌊(p + r) / 2⌋ // 분할: 중간 지점 계산
     MERGE-SORT(A, p, q) // 정복: 왼쪽 하위 문제 재귀적으로 정렬
     MERGE-SORT(A, q + 1, r) // 정복: 오른쪽 하위 문제 재귀적으로 정렬
     MERGE(A, p, q, r) // 결합: 정렬된 두 하위 배열을 병합
```
`MERGE-SORT(A, 1, n)`으로 초기 호출합니다.

**MERGE(A, p, q, r)**
```
1. n1 = q - p + 1 // 첫 번째 부분 배열의 크기
2. n2 = r - q // 두 번째 부분 배열의 크기
3. L[1..n1+1]과 R[1..n2+1] 임시 배열 생성
4. 첫 n1개 요소를 L에, 다음 n2개 요소를 R에 복사
5. L[n1 + 1] ← ∞; R[n2 + 1] ← ∞ // 센티넬(Sentinel) 값 삽입
6. i ← 1; j ← 1 // L과 R 배열의 시작 인덱스
7. for k ← p to r // 원본 배열 A에 병합된 결과 채우기
8.   do if L[i] ≤ R[j]
9.     then A[k] ← L[i]
10.      i ← i + 1
11.  else A[k] ← R[j]
12.      j ← j + 1
```

#### 파이썬 코드 (Python Code)

```python
def mergeSort(arr, l, r):
    if l < r:
        # (l+r)//2와 동일하지만, 큰 l과 h에 대한 오버플로우 방지
        m = l+(r-l)//2
        # 첫 번째와 두 번째 절반 정렬
        mergeSort(arr, l, m)
        mergeSort(arr, m+1, r)
        merge(arr, l, m, r)

def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    # 임시 배열 생성
    L =  * (n1)
    R =  * (n2)

    # 임시 배열 L[]와 R[]로 데이터 복사
    for i in range(0, n1):
        L[i] = arr[l + i]
    for j in range(0, n2):
        R[j] = arr[m + 1 + j]

    # 임시 배열을 arr[l..r]로 다시 병합
    i = 0     # 첫 번째 부분 배열의 초기 인덱스
    j = 0     # 두 번째 부분 배열의 초기 인덱스
    k = l     # 병합된 부분 배열의 초기 인덱스
    while i < n1 and j < n2:
        if L[i] <= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    # L[]에 남아있는 요소가 있다면 복사
    while i < n1:
        arr[k] = L[i]
        i += 1
        k += 1

    # R[]에 남아있는 요소가 있다면 복사
    while j < n2:
        arr[k] = R[j]
        j += 1
        k += 1

# if __name__ == '__main__':
#     arr =
#     mergeSort(arr,0,len(arr)-1)
#     print(arr)
```

#### 빅 O 분석 (Big O Analysis)

병합 정렬의 시간 복잡도는 다음과 같이 분석할 수 있습니다:

1.  **분할(Divide) 단계**: 배열을 절반으로 나누는 과정은 `log(n)`번 발생합니다. (예: `n=8`일 때 `log₂8 = 3`번 분할).
2.  **병합(Merge) 단계**: 각 단계에서 두 개의 정렬된 컬렉션을 하나의 목록으로 병합하는 비용은 배열의 총 요소 수 `n`에 비례합니다. 즉, **O(n)**의 시간이 걸립니다.

따라서 병합 정렬의 총 실행 시간은 **O(n log n)**이 됩니다. 이는 어떤 알고리즘도 임의의 컬렉션을 이보다 더 나은 시간 안에 정렬할 수 없다는 이론적 하한선(최선의 비교 기반 정렬 알고리즘)과 일치하는 매우 효율적인 성능입니다.

### 결론

지금까지 삽입 정렬과 병합 정렬이라는 두 가지 기본적인 정렬 알고리즘에 대해 알아보았습니다.

*   **삽입 정렬**은 구현이 간단하고 작은 데이터셋이나 거의 정렬된 데이터셋에서 효율적이지만, **O(n²)**의 시간 복잡도로 인해 큰 데이터셋에서는 비효율적입니다.
*   **병합 정렬**은 **분할 정복** 패러다임을 사용하여 항상 **O(n log n)**의 안정적인 성능을 보장하며, 대규모 데이터셋에 매우 적합합니다. 다만, 임시 배열 사용으로 인해 추가적인 공간 복잡도가 발생할 수 있습니다.

이러한 정렬 알고리즘의 이해는 더 복잡한 알고리즘을 학습하고 설계하는 데 중요한 기반이 됩니다. 다음에는 다른 정렬 알고리즘이나 더 깊이 있는 알고리즘 분석에 대해 알아보도록 하겠습니다!